# 一. 概述

​		在Java代码中，类型的加载、连接、与初始化过程都是在程序运行期间完成的。定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息。程序运行期间完成典型例子就是动态代理，其实很多语言都是在编译期就完成了加载。

​		类的加载分为：加载（Loading）、链接（Linking）、初始化（Initialization），其中链接还可分为验证（Verification）、准备（Preparation）及解析（Resolution）。

## 1.1 问题

- 虚拟机什么时候才会加载Class文件并初始化类呢？（类加载和初始化时机）
- 虚拟机如何加载一个Class文件呢？（Java类加载的方式：类加载器、双亲委派机制）
- 虚拟机加载一个Class文件要经历那些具体的步骤呢？（类加载过程/步骤）

# 二. 加载

​		类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。

​		类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

## 2.1 加载任务

- 通过一个类的全限定名来获取此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

## 2.2 加载来源

- 从本地文件系统加载class文件
- 从JAR包加载class文件
- 把一个java源文件动态编译，并执行加载

## 2.3 加载时机

​		虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。类加载器通常无须等到“首次使用”该类时才加载该类。

## 2.4 加载方式

- 隐式加载
  - 类“首次主动使用”时加载
  - 在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
  - 在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
  - 在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件
- 显示加载
  - ClassLoader.loadClass(className)，不会进行初始化
  - Class.forName(String name, boolean initialize,ClassLoader loader)

# 三. 链接



# 四 初始化

​		类的使用包括主动使用和被动使用

- 主动使用：会执行加载、链接、初始化静态域
- 被动使用：只执行加载、连接，不初始化类的静态域



类初始化时机：只有对类主动使用时才会导致类的初始化

## 4.1 初始化任务

- 类初始化阶段是类加载过程的最后一个阶段
- 在初始化阶段，才真正开始执行类中定义的java程序代码（字节码）
- 在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源
- 初始化阶段是执行类构造器<clinit>()方法的过程

## 4.2 初始化时机

​		主动引用

- 虚拟机启动时，main方法所在的类会首先进行初始化（入口）
- 遇到new、getstatic、putstatic或invokestatic字节码指令
  - new关键字实例化对象
  - 读取或设置类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）
  - 调用类的静态方法
-  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（继承）
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化（反射）
- 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。