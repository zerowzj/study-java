# 一. 锁

## 1.1 锁的分类

​		锁分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计。

1. 公平锁和非公平锁

   ​		公平锁是指多个线程按照申请锁的顺序来获取锁。

   ​		非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

   ​		对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

   ​		对于synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

2. 可重入锁

   ​		可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

3. 独占锁和共享锁

   ​		独占锁是指该锁一次只能被一个线程所持有。
   ​		共享锁是指该锁可被多个线程所持有。

   ​		对于Java ReentrantLock而言，其是独占锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独占锁。
   ​		读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
   ​		独占锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独占或者共享。
   ​		对于synchronized而言，当然是独占锁。

4. 互斥锁和读写锁

   ​		独占锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

5. 乐观锁和悲观锁

   ​		乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

   ​		悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

   ​		乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

   ​		从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
   ​		悲观锁在Java中的使用，就是利用各种锁。
   ​		乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

6. 分段锁

   分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
   我们以`ConcurrentHashMap`来说一下分段锁的含义以及设计思想，`ConcurrentHashMap`中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
   当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
   但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
   分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

7. 偏向锁/轻量级锁/重量级锁

   ​		这三种锁是指锁的状态，并且是针对synchronized。在Java 5通过引入锁升级的机制来实现高效synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
   ​		偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
   ​		轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
   ​		重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

8. 自旋锁

   ​		在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。



## 1.2 并发三特性

​		原子性、可见性、有序性

1. 原子性

   一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。

   在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。

   > 注意：不采取任何的原子性保障措施的自增操作并不是原子性的。

   如何保证原子性：

   - 通过 synchronized 关键字定义同步代码块或者同步方法保障原子性。
   - 通过 Lock 接口保障原子性。
   - 通过 Atomic 类型保障原子性。

2. 可见性

   当一个线程修改了共享变量的值，其他线程能够看到修改的值。

   如何保证可见性：

   - 通过 volatile 关键字标记内存屏障保证可见性。
   - 通过 synchronized 关键字定义同步代码块或者同步方法保障可见性。
   - 通过 Lock 接口保障可见性。
   - 通过 Atomic 类型保障可见性。
   - 通过 final 关键字保障可见性。

3. 有序行

   程序执行的顺序按照代码的先后顺序执行。

   如何保证可见性：

   - 通过 synchronized关键字 定义同步代码块或者同步方法保障可见性。

   - 通过 Lock接口 保障可见性。

     

     

     

     









# 二. synchronized

## 2.1 Monitor对象

​		每个对象都有一个Monitor对象相关联，Monitor对象中记录了持有锁的线程信息、等待队列等。Monitor对象包含以下三个字段：

- _owner：记录当前持有锁的线程
- _EntryList：是一个队列，记录所有阻塞等待锁的线程
- _WaitSet：也是一个队列，记录调用 wait() 方法并还未被通知的线程

​        当线程持有锁的时候，线程id等信息会拷贝进owner字段，其余线程会进入阻塞队列entrylist，当持有锁的线程执行wait方法，会立即释放锁进入waitset，当线程释放锁的时候，owner会被置空，公平锁条件下，entrylist中的线程会竞争锁，竞争成功的线程id会写入owner，其余线程继续在entrylist中等待。

> Monitor与synchronized

​		对于synchronized的同步代码块，JVM会在进入代码块之前加上monitorenter ，如果进入monitor成功，线程便获取了锁，一个对象的monitor同一时刻只能被一个线程锁占有。

​		对于同步方法，JVM会讲方法设置 ACC_SYNCHRONIZED 标志，调用的时候 JVM 根据这个标志判断是否是同步方法。

​		采用synchronized给对象加锁会使线程阻塞，因而会造成线程状态的切换，而线程状态的切换必须要操作系统来执行，因此需要将用户态切换为内核态，这个切换的过程是十分耗时的都需要操作系统来帮忙，有可能比用户执行代码的时间还要长。

​		synchronized是JVM级别的锁，它在不断被优化着，从目前来看synchronized已经远没有以前那么“重”了，也大概就是JUC包源码（如ConcurrentHashMap）中大量使用synchronized的原因吧。



![img](https://img2018.cnblogs.com/blog/820029/201908/820029-20190807082208764-718517690.png)

## 3.1 背景知识

### 3.1.1 Java对象布局







### 3.1.1 Java内存模型

​		这里主要描述的线程，工作内存，主存的变量的读写关系：

1. 主存存放线程需要操作的变量，但线程并不直接操作主存
2. 每个线程读取主存变量都是先拷贝一份到工作内存中，不同线程工作内存互不干扰
3. 线程修改了工作内存后，再写回主存中
4. 每次从主存读写的过程都需要经过8原子性操作（use load read lock和assign store write unlock）

## 3.1 关键字synchronized

​		synchronized是一种独占式的重量级锁，在运行到同步方法或者同步代码块的时候，让程序的运行级别由用户态切换到内核态，把所有的线程挂起，通过操作系统的指令，去调度线程。这样会频繁出现程序运行状态的切换，线程的挂起和唤醒，会消耗系统资源，为了提高效率，引入了偏向锁、轻量级锁、尽量让多线程访问公共资源的时候，不进行程序运行状态的切换。

synchronized作用：

1. 确保线程互斥的访问同步代码 
2. 保证共享变量的修改能够及时可见
3. 有效解决重排序问题

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

1. 普通同步方法，锁是当前实例对象
2. 静态同步方法，锁是当前类的class对象
3. 同步方法块，锁是括号里面的对象

synchronized作为锁特点：

1. 不可中断

### 3.1.1 几个概念

1. 自旋

   互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

   - 自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在JDK 1.6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的， 所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作， 反而会带来性能的浪费。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。
   - 在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象 上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间， 比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自 旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。

2. 锁削除

3. 锁粗化

   ​		我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快地拿到锁。

   ​		大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（锁粗化）到整个操作序列的外部。

### 3.1.2 实现原理

​		synchronized是在jvm中实现，是基于进入和退出Monitor对象来实现方法和代码块的同步

1. 同步代码块

   ​		monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；

2. 同步方法

   ​		synchronized方法则会被翻译成普通的方法调用和返回指令如：invokevirtual、areturn指令，有一个ACC_SYNCHRONIZED标志，JVM就是通过该标志来判断是否需要实现同步的，具体过程为：当线程执行该方法时，会先检查该方法是否标志了ACC_SYNCHRONIZED，如果标志了，线程需要先获取monitor，获取成功后才能调用方法，方法执行完后再释放monitor，在该线程调用方法期间，其他线程无法获取同一个monitor对象。其实本质上和synchronized块相同，只是同步方法是用一种隐式的方式来实现，而不是显式地通过字节码指令。

### 3.1.3 锁状态

​		锁一共有四种状态（由低到高的次序）：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁的等级只可以升级，不可以降级。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

1. 偏向锁

   ​		大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得。为了让线程获得所得代价更低而引入了偏向锁，当一个线程访问同步代码块并获取锁时，会在线程的栈帧里创建lockRecord，在lockRecord里和锁对象的MarkWord里存储线程的线程id。

   ​		以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

   ​		如果测试成功，表示线程已经获得了锁。如果测试失败，说明是其他线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活。

   ​		如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

2. 轻量级锁

   线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果，完成自旋策略还是发现线程没有释放锁，或者让别的线程占用，则线程试图将轻量级锁升级为重量级锁。

   轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

3. 重量级锁

   就是让争抢锁的线程从用户态转换成内核态。让cpu借助操作系统进行线程协调。

   具体流程如下：

   | 锁       | 优点                                                         | 缺点                                           | 适用场景                                                     |
   | -------- | ------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------------------------------ |
   | 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景（只有一个线程进入临界区）   |
   | 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到索竞争的线程，使用自旋会消耗CPU  | 追求响应速度，同步块执行速度非常快（多个线程交替进入临界区） |
   | 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行速度较慢（多个线程同时进入临界区）     |



## 3.2 关键字volatile

​		volatile是一种轻量且在有限的条件下线程安全技术，它保证修饰的变量的可见性和有序性，但非原子性。相对于synchronize高效，而常常跟synchronize配合使用。

### 3.2.1 可见性

​		volatile的JMM特殊性：

1. 操作use之前必须先执行read和load操作
2. 操作assign之后必须执行store和write操作

​        由特殊性保证了read、load和use的操作连续性，assign、store和write的操作连续性，从而达到工作内存读取前必须刷新主存最新值；工作内存写入后必须同步到主存中。读取的连续性和写入的连续性，看上去像线程直接操作了主存。

> 扩展：lock和unlock操作并不直接开放给用户使用，而是提供给像Synchronize关键字指定monitorenter和monitorexit隐式使用。关于Synchronize的监听器锁monitor，javac编译后会在作用的方法前后增加monitorenter和monitorexit指令，详细的可以查看Synchronize原理。

### 3.2.1 非原子性

​		use和assign这两个操作整体上不是一个连续性的原子操作。volatile本身并不对数据运算处理维持原子性，强调的是读写及时影响主存。

### 3.3.3 有序性





# 三. volatile

# 四. Lock

## 3.1 背景知识



# 九. 锁优化

## 1.1 使用乐观锁优化并发性能

### 1.1.1 什么是乐观锁

​		乐观锁，顾名思义，就是说在操作共享资源时，它总是抱着乐观的态度进行，它认为自己可以成功地完成操作。但实际上，当多个线程同时操作一个共享资源时，只有一个线程会成功，那么失败的线程呢？乐观锁不会像悲观锁一样在操作系统中挂起，而仅仅是返回，并且系统允许失败的线程重试，也允许自动放弃退出操作。

​		所以，乐观锁相比悲观锁来说，不会带来死锁、饥饿等活性故障问题，线程间的相互影响也远远比悲观锁要小。更为重要的是，乐观锁没有因竞争造成的系统开销，所以在性能上也是更胜一筹。

### 1.1.1 乐观锁实现原理

​		CAS 是实现乐观锁的核心算法，它包含了 3 个参数：V（需要更新的变量）、E（预期值）和 N（最新值）。

​		只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回 V 的真实值。

### 1.1.1 CAS 如何实现原子操作

​		在 JDK 中的 concurrent 包中，atomic 路径下的类都是基于 CAS 实现的。AtomicInteger 就是基于 CAS 实现的一个线程安全的整型类。下面我们通过源码来了解下如何使用 CAS 实现原子操作。

```java
//基于CAS操作更新值
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
//基于CAS操作增1
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
//基于CAS操作减1
public final int getAndDecrement() {
    return unsafe.getAndAddInt(this, valueOffset, -1);
}
```

​		我们可以看到 AtomicInteger 的自增方法 getAndIncrement 是用了 Unsafe 的 getAndAddInt 方法，显然 AtomicInteger 依赖于本地方法 Unsafe 类，Unsafe 类中的操作方法会调用 CPU 底层指令实现原子操作。

### 1.1.1 优化 CAS 乐观锁

​		虽然乐观锁在并发性能上要比悲观锁优越，但是在写大于读的操作场景下，CAS 失败的可能性会增大，如果不放弃此次 CAS 操作，就需要循环做 CAS 重试，这无疑会长时间地占用 CPU。

​		在 Java7 中，通过以下代码我们可以看到：AtomicInteger 的 getAndSet 方法中使用了 for 循环不断重试 CAS 操作，如果长时间不成功，就会给 CPU 带来非常大的执行开销。到了 Java8，for 循环虽然被去掉了，但我们反编译 Unsafe 类时就可以发现该循环其实是被封装在了 Unsafe 类中，CPU 的执行开销依然存在。

```java
public final int getAndSet(int newValue) {
        while (true) {
            int current = get();
            if (compareAndSet(current, newValue))
                return current;
        }
    }
```

​		在 JDK1.8 中，Java 提供了一个新的原子类 LongAdder。LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好，代价就是会消耗更多的内存空间。