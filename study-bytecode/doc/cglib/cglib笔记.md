# 一. 介绍

​		cglib是一款开源的动态代理库，与JDK动态代理基于接口的代理机制不同，cglib通过为被代理的类生成一个子类并重写被代理的方法实现代码的动态植入。

​		因此，cglib无法代理被`final`修饰的类或方法以及静态方法。

​		cglib基于AMS框架实现，是JDK动态代理的有效补充，可以用于AOP编程，比如日志打印、安全控制、统一鉴权等。

​		因为AMS框架是基于`.class`字节码的，因为无法用于android平台。

​		cglib动态代理无需实现接口，通过生成子类字节码来实现，比反射快一点，没有性能问题。但是由于cglib会继承被代理类，需要重写被代理方法，所以被代理类不能是final类，被代理方法不能是final。相对来说cglib应用广泛一点。



原理：

​		动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。







## JDK静态代理

实现：代理类与委托类实现同一接口，并且在代理类中需要硬编码接口

优点：实现简单，容易理解

缺点：代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低

## JDK动态代理

实现：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理

优点：不需要硬编码接口，代码复用率高

缺点：只能够代理实现了接口的委托类

特点：底层使用反射机制进行方法的调用 

## CGLIB动态代理

实现：代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理

优点：可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口

缺点：不能对final类以及final方法进行代理

特点：底层将方法全部存入一个数组中，通过数组索引直接进行方法调用





区别

1. JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
2. JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
3. JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。

# 注意

由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。





