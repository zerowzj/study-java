# 一. 概述

​		在Java代码中，类型的加载、连接、与初始化过程都是在程序运行期间完成的。定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息。程序运行期间完成典型例子就是动态代理，其实很多语言都是在编译期就完成了加载。

​		类的加载分为：加载（Loading）、链接（Linking）、初始化（Initialization），其中链接还可分为验证（Verification）、准备（Preparation）及解析（Resolution）。

## 1.1 问题

- 虚拟机什么时候才会加载Class文件并初始化类呢？（类加载和初始化时机）
- 虚拟机如何加载一个Class文件呢？（Java类加载的方式：类加载器、双亲委派机制）
- 虚拟机加载一个Class文件要经历那些具体的步骤呢？（类加载过程/步骤）





# 二. 加载

​		类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。

​		类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

## 2.1 加载任务

- 通过一个类的全限定名来获取此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

## 2.2 加载来源

- 从本地文件系统加载class文件
- 从JAR包加载class文件
- 把一个java源文件动态编译，并执行加载

## 2.3 加载时机

​		虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。类加载器通常无须等到“首次使用”该类时才加载该类。

## 2.4 加载方式

- 隐式加载
  - 类“首次主动使用”时加载
  - 在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
  - 在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
  - 在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件
- 显示加载
  - ClassLoader.loadClass(className)，不会进行初始化
  - Class.forName(String name, boolean initialize,ClassLoader loader)





# 三. 链接







# 四 初始化

​		类初始化阶段是类加载过程的最后一个阶段。

​		类的使用包括主动使用和被动使用：

- 主动使用：会执行加载、链接、初始化静态域
- 被动使用：只执行加载、连接，不初始化类的静态域

## 4.1 初始化任务

- 在初始化阶段，才真正开始执行类中定义的java程序代码（字节码）
- 在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源
- 初始化阶段是执行类构造器<clinit>()方法的过程

## 4.2 初始化时机

​		只有对类主动使用时才会导致类的初始化，以下为类的主动使用：

- 虚拟机启动时，main方法所在的类会首先进行初始化（入口）
- 遇到new、getstatic、putstatic或invokestatic字节码指令（实例化及访问static）
  - new关键字实例化对象
  - 读取或设置类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）
  - 调用类的静态方法
-  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（继承）
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化（反射）
- 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。



## 4.4 类构造器<clinit>

​		<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

​		类构造器<clinit>()与实例构造器<init>()不同。类构造器不需要程序员进行显式调用，虚拟机会保证在子类类构造器<clinit>()执行之前，父类的类构造<clinit>()执行完毕。由于父类的构造器<clinit>()先执行，也就意味着父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器<clinit>()。

​		在多线程环境下，虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出后，其他线程在唤醒之后不会再次进入/执行<clinit>()方法。因为 在同一个类加载器下，一个类型只会被初始化一次。