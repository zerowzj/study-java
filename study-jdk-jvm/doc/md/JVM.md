# 一. Java内存区域

## 1.1 概述

​		对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

1. 基本问题
   - Java内存区域（运行时数据区）
   - Java对象创建过程（）
   - 对象的访问定位的两种方式（句柄和直接指针）
2. 拓展问题
   - String类和常量池
   - 8种基本类型和包装类和常量池

## 1.2 运行时数据区

​		Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同

线程私有：

- 计数器
- 虚拟机栈
- 本地方法栈

线程共享：

- 堆
- 方法区
- 直接内存（非运行时数据区的一部分）

### 1.2.1 程序计数器

​		程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

​		由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。

​		因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

​		如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 1.2.2 本地方法栈

### 1.2.3  Java虚拟机栈

​		Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

​		虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

​		在活动线程中，只有位千栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。

> 虚拟机栈是面向方法的

1. **局部变量表**

   ​		局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法，则在 index[0] 位置上存储的是方法所属对象的实例引用，一个引用变量占 4 个字节，随后存储的是参数和局部变量。

   ​		虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。

2. 操作栈

3. 动态链接

   每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。

4. 方法返回地址

   方法执行时有两种情况退出：

   - 正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；
   - 异常退出
   - 

   

   

   

### 1.2.4 Java堆

​		对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

​		堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。

​		Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

### 1.2.5 方法区（JDK1.8以前）

​		方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

​		方法区也被称为永久代。很多人都会分不清方法区和永久代的关系。

​		JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK1.8 开始使用元空间（Metaspace），以前永久代的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。

1. 方法区和永久代的关系

   ​		《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

2. 常用参数

   ​		JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

   ```shell
   #方法区 (永久代) 初始大小
   -XX:PermSize=N
   #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
   -XX:MaxPermSize=N
   ```

   ​		相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

   JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：

   ```shell
   #设置 Metaspace 的初始（和最小大小）
   -XX:MetaspaceSize=N
   #设置 Metaspace 的最大大小
   -XX:MaxMetaspaceSize=N
   ```

   与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

3. 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

   - 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

     你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

   - 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

   - 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

### 1.2.6 运行时常量池

​		运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​		一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

​		运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。

​		既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

> 注意概念：运行时常量池和Class文件常量池

### 1.2.7 直接内存

​		直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

​		JDK1.4 中新加入的 NIO 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

​		本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 1.3 元空间（JDK1.8）

​		Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。

### 1.3.1 为什么被移除？

​		在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如`Class`和`Method`。每当一个类初次被加载的时候，它的元数据都会放到永久代中。

​		永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 *java.lang.OutOfMemoryError: PermGen*，为此我们不得不对虚拟机做调优。

​		那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因

1. 由于 PermGen 内存经常会溢出，引发恼人的 *java.lang.OutOfMemoryError: PermGen*，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。

2. 移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。

   根据上面的各种原因，PermGen 最终被移除，**方法区移至 Metaspace，字符串常量移至 Java Heap**。

### 1.3.1 探秘元空间

​		首先，Metaspace（元空间）是哪一块区域？官方的解释是：

```
In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.
```

​		也就是说，JDK 8 开始把类的元数据放到本地堆内存（native heap）中，这一块区域就叫 Metaspace，中文名叫元空间。

1. 优点

   ​		使用本地内存有什么好处呢？最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让 Metaspace 变得无限大显然是不现实的，因此我们也要限制 Metaspace 的大小：使用 -XX:MaxMetaspaceSize 参数来指定 Metaspace 区域的大小。JVM 默认在运行时根据需要动态地设置 MaxMetaspaceSize 的大小。

2. GC

   ​		如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。

   ​		为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。

3. 新增 JVM 参数

   - -XX:MetaspaceSize

     分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，*the initial high-water-mark* )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大

   - -XX:MaxMetaspaceSize

     分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。

   - -XX:MinMetaspaceFreeRatio

     表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收

   - -XX:MaxMetaspaceFreeRatio

     表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收



# 二. HotSpot 虚拟机对象探秘

## 2.1 对象的内存布局

​		在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对齐填充、实例数据和对象头。

### 2.1.1 对齐填充

​		Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。	 

​		Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节（byte）的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。对于32位系统，对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

​		对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。

### 2.1.2 实例数据

​		实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

| 类型          | 占用字节（byte）                               | 说明 |
| ------------- | ---------------------------------------------- | ---- |
| byte          | 1                                              |      |
| boolean       | 1                                              |      |
| short         | 2                                              |      |
| char          | 2                                              |      |
| int           | 4                                              |      |
| float         | 4                                              |      |
| long          | 8                                              |      |
| double        | 8                                              |      |
| reference类型 | 32位系统上占用 4 bytes；64位系统上占用 8 bytes |      |

### 2.1.3 对象头

​		Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等），我们称为 **Mark Word**；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例，我们称为 **Klass Pointer**。

#### 2.1.3.1 对象头形式

| 虚拟机位数 | 内容                  | 说明                          |
| ---------- | --------------------- | ----------------------------- |
| 32/64 bit  | Mark Word             | 存储对象的hash code或锁信息等 |
| 32/64 bit  | Class Metadata Adress | 存储到对象类型数据的指针      |
| 32/32 bit  | Array Length          | 数组的长度（如果当前是数组）  |

1. 普通对象

   ```ruby
   32位
   |--------------------------------------------------------------|
   |                     Object Header (64 bits)                  |
   |------------------------------------|-------------------------|
   |        Mark Word (32 bits)         |    Klass Word (32 bits) |
   |------------------------------------|-------------------------|
    
   64位
   |--------------------------------------------------------------|
   |                     Object Header (128 bits)                 |
   |------------------------------------|-------------------------|
   |        Mark Word (64 bits)         |    Klass Word (64 bits) |
   |------------------------------------|-------------------------|
   ```

2. 数组对象

   ```ruby
   32位
   |-------------------------------------------------------------------------------|
   |                     Object Header (96 bits)                                   |
   |------------------------------|-----------------------|------------------------|
   |      Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |
   |------------------------------|-----------------------|------------------------|
   
   64位
   |-------------------------------------------------------------------------------|
   |                     Object Header (96 bits)                                   |
   |------------------------------|-----------------------|------------------------|
   |      Mark Word(64bits)       |    Klass Word(64bits) |  array length(32bits)  |
   |------------------------------|-----------------------|------------------------|
   ```

   

#### 2.1.3.2 Mark Word

​		这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。Mark Word的位长度为JVM的一个Word大小，也就是说32位JVM的为32位，64位JVM为64位。
​		为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，不同标记位下的Mark Word示意如下：

```ruby

|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  |       State        |
|-------------------------------------------------------|--------------------|
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
|-------------------------------------------------------|--------------------|
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
|-------------------------------------------------------|--------------------|
|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                              | lock:2 |    Marked for GC   |
|-------------------------------------------------------|--------------------|

        
|------------------------------------------------------------------------------|
|                                  Mark Word (64 bits)                         |
|------------------------------------------------------------------------------|
| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |
|------------------------------------------------------------------------------|
| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |
|------------------------------------------------------------------------------|
|                       ptr_to_lock_record:62                         | lock:2 |
|------------------------------------------------------------------------------|
|                     ptr_to_heavyweight_monitor:62                   | lock:2 |
|------------------------------------------------------------------------------|
|                                                                     | lock:2 |
|------------------------------------------------------------------------------|
```



#### 2.1.3.3 Klass Pointer

​		这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。
 如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项`+UseCompressedOops`开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：

1. 每个Class的属性指针（即静态变量）
2. 每个对象的属性指针（即对象变量）
3. 普通对象数组的每个元素指针

当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。



#### 2.1.3.4 Array Length

​		如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。



## 2.2 对象的状态

​		Java对象有5种状态，分别为：无状态、偏向锁、轻量级锁、重量级锁、GC标记

## 2.3 对象的创建

1. **类加载检查**

   虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2. **分配内存**

   在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

   - 内存分配的两种方式

   - 内存分配并发问题

     在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全

     - CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
     - TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

3. **初始化零值**

   内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. **设置对象头**

   初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. **执行init方法**

   在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 2.4 对象的定位

​		建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：

1. 句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
2. 直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

​        这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。



# 三. 类加载过程

## 3.1 什么是类加载？

​		在Java代码中，类的加载、链接和初始化都是在程序运行期间完成的。类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

​		类加载过程包括：加载（Loading）、链接（Linking）初始化（Initialization）

- 虚拟机什么时候才会加载Class文件并初始化类呢？（类加载和初始化时机）
- 虚拟机如何加载一个Class文件呢？（Java类加载的方式：类加载器、双亲委派机制）
- 虚拟机加载一个Class文件要经历那些具体的步骤呢？（类加载过程/步骤）

## 3.2 加载过程

### 3.2.1 加载

1. 加载任务

- 通过一个类的全限定名来获取此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

2. 加载来源

- 从本地文件系统加载class文件
- 从JAR包加载class文件
- 从JAR包加载class文件
- 把一个java源文件动态编译，并执行加载

3. 加载时机

​		虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。类加载器通常无须等到“首次使用”该类时才加载该类。

- 启动时加载

  应用程序启动时，所有类不会被一次性加载，如果一次性加载，内存资源有限，可能会影响应用程序的正常运行。一个类真正被加载的时机是在创建对象的时候。

- 预加载

  类加载器并不需要等到某个类被"首次主动使用"时再加载该类。JVM规范规定JVM可以预加载某一个类。


4. 加载方式

- 隐式加载

  - 类“首次主动使用”时加载

  - 在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class

  - 在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class

  - 在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件

- 显示加载

  - ClassLoader.loadClass(className)，不会进行初始化

  - Class.forName(String name, boolean initialize,ClassLoader loader)

### 3.2.2 链接

1. 验证

​		验证是链接的第一阶段，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

​		验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

2. 准备

​		准备阶段进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。这些变量所使用的内存都将在方法区中进行分配。如果类字段的字段属性表中存在ConstantValue属性（同时被final和static修饰），在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

3. 解析

​		解析是虚拟机将常量池内的符号引用替换为直接引用（内存地址）的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

​		常量池包括字面量和符号引用。字面量比较接近Java语言层面，如String字符串，声明final的常量等。符号引用包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

### 3.2.3 初始化

1. 初始化任务

2. 初始化时机

​		虚拟机规范指明有且只有五种情况必须立即对类进行初始化。类初始化自然发生在加载、验证、准备之后。

- 主动引用
  - 虚拟机启动时，main方法所在的类会首先进行初始化。
  - 遇到new、getstatic、putstatic或invokestatic字节码指令。new关键字实例化对象，读取或设置类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外），调用类的静态方法。
  - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。（继承）
  - 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。（反射）
  - 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
- 被动引用
  - 通过子类引用父类的静态字段，不会导致子类初始化
  - 通过数组定义类引用类，不会触发此类的初始化
  - 类A引用类B的static final常量不会导致类B初始化
  - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发定义常量的类的初始化
  - 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化
  - 通过ClassLoader默认的loadClass方法，也不会触发初始化动

3. 

4. 

5. 类初始化和类实例化

​		类的实例化与类的初始化是两个完全不同的概念。类的初始化是指为类中各个类成员（被static修饰的成员变量）赋初始值的过程，是类生命周期中的一个阶段。类的实例化是指创建一个类的实例（对象）的过程。

​		在类都没有初始化完毕之前，能直接进行实例化相应的对象吗？在同一个类加载器下，一个类型只会被初始化一次。一旦开始初始化一个类型，无论是否完成，后续都不会再重新触发该类型的初始化阶段了。把实例初始化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置。

### 3.2.4 使用

### 3.2.5 卸载

# 四. 类加载器





# 五 垃圾回收







































































​		

# 

# 2. 对象创建

​		

## 1.2 对象创建时机

- 使用new关键字创建对象，这种方式在Java规范中被称为 : 由执行类实例创建表达式而引起的对象创建

- 使用Class类的newInstance方法（反射机制）

- 使用Constructor类的newInstance方法（反射机制）

- 使用Clone方法创建对象

- 使用（反）序列化机制创建对象

  

## 1.2 对象创建过程

### 1.2.1 创建过程

​		当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值（零值）。内存分配完成之后，Java虚拟机就会开始对新创建的对象按照程序员的意志进行初始化。

### 1.2.2 初始化

​		对象创建过程的初始化结构包括实例变量初始化、实例代码块初始化、构造函数初始化。

#### 1. 实例变量初始化和代码块初始化

​		实例变量初始化可以在声明时直接对实例变量进行赋值或者通过实例代码块对实例变量进行赋值。实际上，该过程将在构造函数执行之前完成这些初始化操作。对实例变量直接赋值或者使用实例代码块赋值，编译器会将其中的代码放到类的构造函数中去。这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。

- 123123

- 构造函数初始化

#### 2. 构造函数初始化

